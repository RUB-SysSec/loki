# Experiment 1 Correctness

There's a number of approaches to assert correctness; we are limited in the fact that we use the binaries on which the evaluation is based (and the number of tests to assert correctness has been signficantly increased during revision) -- these binaries run the obfuscated function 10k times for timing measurements; this combined with repeated cost of spawning new processes is costly, limiting throughput. As a result, we inject a custom constructor into the program which executes a number of inputs. To do so, we first need to (1) create the inputs, (2) get a ground truth of what output we expect for the inputs, before we then (3) can run these inputs on each obfuscated instance.

Note that we assume here you have conducted the [dead_code_elimination](../dead_code_elimination/) experiment before and built a number of binaries in `/home/user/evaluation/experiment_01_02_03_dce/`, which we will re-use here. If you have not, build binaries as follows:


## Build Binaries
First, we need to build binaries with the following Rust component config:

```
# Settings:
    rewrite_mba: true,
    superoptimization: true,
    schedule_non_deterministic: true,
```

To do so, run the following:
```
mkdir -p /home/user/evaluation/experiment_01_02_03_dce/
cd ../../loki/
python3 obfuscate.py /home/user/evaluation/experiment_01_02_03_dce/binaries --instances 10 --allow aes_encrypt des_encrypt md5 rc4 sha1
```


# Correctness-checker

## Setup
To avoid memory exhaustion from reading huge input files, we rely on kernel same-page merging (and mmapping the file)
```
echo 1 | sudo tee  /sys/kernel/mm/ksm/run (only blade_14)
```

## Step 1: Generate input pairs
a) Hardcode number of inputs per lenght of inputs in src code
b) Run input-generator using `cargo --release run`

This will create a file called `inputs.json` in your current working direcotry. This file may consist of several megabytes up to gigabytes and contains all inputs requested. You can change the number of inputs by changing the value of `NUM_RANDOM_INPUTS_PER_LENGTH_LEVEL` in [input-generator/src/main.rs](input-generator/src/main.rs). This value governs how many inputs for each length level between 16 and 128 (both inclusive) are produced (by default, it is set to 100, resulting in 122,000 inputs to test).

## Step 2: Generate ground truth
a) Build correctness-oracle
b) Run python wrapper [build_ground_truth.py](./build_ground_truth.py): 
```
python3 build_ground_truth.py /home/user/evaluation/experiment_01_02_03_dce/ -i ./inputs.json
```

Internally, this will---for all targets (or those selected via `--only`)---execute the `orig_exe` with all inputs in the specified JSON file. The outputs recorded for the input (tuple) are stored in another JSON file at `~/evaluation/eval_crypto_mba_0108/workdirs/<target>/inputs.json`. The call to orig_exe is roughly equivalent to `LD_PRELOAD=$PWD/target/debug/libcorrectness_oracle.so <path_to_evaluation_dir>/workdirs/<TARGET>/bin/orig_exe`.

## Step 3: Evaluate ground truth
a) Build correctness-checker-runtime
b) Run python wrapper [checker.py](./checker.py) as follows: 
```
python3 checker.py /home/user/evaluation/experiment_01_02_03_dce/
```

Internally, this will---for all targets (or those selected via `--only`)---identify all obfuscated instances (typically, `vm_alu000` to `vm_alu999`) and execute the `obf_exe` with all inputs in the JSON file generated by `build_ground_truth.py`. The result of the computation is checked against the one produced by the respective `orig_exe`. The call to the `obf_exe`s is roughly equivalent to `LD_PRELOAD=$PWD/target/debug/libcorrectness_checker_runtime.so <path_to_evaluation_dir>/workdirs/<TARGET>/instances/vm_alu<NUMBER>/obf_exe`
